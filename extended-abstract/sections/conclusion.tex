%!TEX root = ../article.tex

\section{Conclusions}
\label{chapter:conclusion}

The representation of source code dramatically affects its comprehensibility and usability~\cite{baecker1986design}. In this thesis, we found that by using image resources, namely sketches and diagrams, applied to generative design programs it is possible to enhance the program visualization. Moreover, accelerating the program execution allows users to test their mental models~\cite{brooks1977towards,robins2003learning} quickly. In fact program comprehension is improved because (1) source code becomes documented with media-rich resources, and (2) the effect of changes in the program becomes instantly visible.

Based on Learnable~Programming and Literate Programming we propose an interactive environment tailored for generative design. This programming environment helps the designer in establishing a strong correlation between the \gls{gd} program, and the geometric sketches that it represents, as a result, it eliminates the first barriers to learning, allowing designers to read the code and to understand it at a higher level. It also encourages the developer to test his ideas quickly, by seeing the result of his action.

Among the generative design systems which support programming in a textual form~\cite{aish2012designscript,lopes2011portable}, only one~\cite{lopes2011portable} supports other elements in the editor, besides plain text. However, none of them associates the source code with images nor even supporting any correlation between them. On the other hand, the only way to get immediate feedback in these systems is by a stepwise debug which stops the entire program execution, disabling code to be edited. So in debug mode users can only change single lines of execution, making it difficult, or even impossible, to have immediate feedback.

Immediate feedback avoids the edit-compile-run cycle, anticipating as much as possible the result of a change in the code. When this mechanism is associated with Rosetta tool, it creates a playground where architects can create models interactively. So, this tool promotes the essential aspect in Architecture: the creativity.  However, similar to what happens with all other \gls{gd} systems, this tool will not scale for all \gls{gd} programs, due to the render performance of \gls{cad} tools. Therefore, using Rosetta architects can use a faster backend to test their ideas, then moving to their preferred backend.

Sketch-program correlation mechanism promotes the documentation in \gls{gd} programs besides it correlates the source code with images. However, to associate images with code users must intervene in this process by strictly identifying the symbols in the picture with the identities in the program. Integration with \gls{ocr} engine is part of the system architecture, however due to the bad experiences in using the \gls{ocr} to recognize handwritten symbols, we skipped this step in the actual implementation.

In this thesis, several features were proposed, the majority of them based on successful research projects. For example, the idea of improving the context view of statement blocks by allowing users to focus on the main fragment of code was proposed in Barista~\cite{ko2006barista} project, and we used it to implement the expand/collapse feature. Like this idea, other helpful features and strategies were discussed, such as how to serialize images with code, how to prevent that images impair in the usability of the code text editor, among others.

The implemented tools just define a first path to follow.  Future work, regarding the program-sketch tool would (1) integrate the OCR engine in the current flow, (2) provide facilities to allow users to edit images directly in the code editor, (3) provide flexibility to bind any program fragment to any picture. Regarding the immediate feedback tool, feature work would (1) create an adaptative sliders widget, (2) study a better mechanism to predict the slider values, (3) implement in \gls{cad} backends the possibility to show differences between model changes, and (4) implement the autocomplete tool that immediately executes the selected expression in the list of options.

We believe that there is a bright feature ahead for innovations in programming environments, and we hope that implementation programming tools like those discussed in this thesis will make such innovations more feasible, more usable, and more useful.