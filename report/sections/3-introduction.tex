%!TEX root = ../report.tex

% 
% Introduction
% 

\section{Introduction}

Challenges in understanding programs are all too familiar since the early days of computing. At that time we wrote programs in \textit{absolute binary}~\cite{hamming2003art}. It is a numeric representation typically expressed by a sequence of zeros and ones, meaning that the programs were represented as a sequence of instructions and addresses both written in binary. To understand a program in this form is almost impossible.

Since early days, as Fred Brooks pointed out in his influential essay~\cite{bullet1987essence}, we have come to accept that \textit{there is no silver bullet} to understand a program. Fortunately, in recent years, the field of \textit{program comprehension}~\cite{rugaber1995program} has evolved considerably, because, mainly, a program that is not comprehended cannot be changed, shared and communicated.

The area of program comprehension has shown that to understand a program, a \textit{silver bullet} may not be required. This field came up with several theories that provide rich explanations of how programmers understand programs. For instance, the \textit{top-down} theory~\cite{brooks1977towards} says that to comprehend a program, the programmer must create a mental model of the program's structure and behavior. This mental model is a set of hypothesis which the programmer confirms or rejects, based on evidence found in the code.

In response to these theories or in parallel with them, many environments and innovative tools were created or updated to math them. Some of the examples are: sophisticated frameworks to support the more rapid construction and integration of tools~\cite{DesRivieres2004}, advanced programming environments with intelligent users interface~\cite{carlson2005eclipse,boudreau2002netbeans,intellij2001intellij,guckenheimer2006software}, and even simple tools designed for learning environments~\cite{papert1980mindstorms,Kay1993,Reas2006,findler2002drscheme,GuoSIGCSE2013,mcdirmid2013usable}. In parallel to these advances, there are more researchers from other fields interested in the aspects of program comprehension, for example, in the Architecture field, new tools~\cite{aish2012designscript,lopes2011portable} are being proposed to support the \textit{generative design}; a procedural method for generating architectural models~\cite{mccormack2004generative}.

Many of these tools would be unnecessary if the programs were documented properly, the oldest recommended practice in software engineering, i.e. comment the source code, is the most important artifact to understand a system and to maintain it, as showed in~\cite{de2005study}. Unfortunately, writing documentation is perceived as a tiresome task and, thus, is frequently avoided (e.g.~\cite{sousa1998survey}). This negatively affects software development including the several areas where it is applied. A result of the lack of program documentation is that programmers must spend a significant amount of time extracting relevant ideas from the irrelevant ones.

We think that, by creating well designed tools, it is possible to improve the \textit{program documentation}. We address this problem, in a way that documenting a program will not be a tiresome task. Consequently, a well documented program will be easier to comprehend, modify, and share. In this way, programmers will spend less time and effort to understand a program by enhancing the overall program comprehension.