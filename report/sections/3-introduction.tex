%!TEX root = ../report.tex

% 
% Introduction
% 

\section{Introduction}

Challenges in understanding programs are all too familiar since the early days of computing. At that time we wrote programs in \textit{absolute binary}~\cite{hamming2003art}. A numeric representation typically expressed by a sequence of zeros and ones. Meaning, the programs were represented as a sequence of instructions and addresses both written in binary. Understand a program in this form is almost hopeless.

From these early days we have come to accept that \textit{there is no silver bullet}~\cite{bullet1987essence} to understand a program. Fortunately, in recent years the field of \textit{program comprehension}~\cite{rugaber1995program} has evolved considerably. The main motivation behind this evolution is due the fact that a program that is not comprehended cannot be changed, shared and communicated. 

Unlike our first idea, the area of program comprehension has shown that to understand a program, perhaps, a silver bullet is unnecessary. This field came up with a wide variety of theories that provide rich explanations of how programmers understand programs. For instance, the \textit{top-down} theory~\cite{brooks1977towards} says that to comprehend a program the programmer creates a mental model of the program's structure and behavior. This mental model is a set of certain hypothesis which the programmer confirms or rejects them based on evidence found in the code.

In response to these theories, many powerful tools and innovative software processes have evolved to improve comprehension activities. For example, sophisticated frameworks to support the more rapid construction and integration of tools~\cite{DesRivieres2004}, advanced programming environments with intelligent users interface~\cite{carlson2005eclipse,boudreau2002netbeans,intellij2001intellij,guckenheimer2006software}, and even simple tools designed for learning environments~\cite{papert1980mindstorms,Kay1993,Reas2006,findler2002drscheme,GuoSIGCSE2013,mcdirmid2013usable}. In parallel to these tool advances, there are more researchers from other disciplines that are interested in the aspects of program comprehension. For example, in the Architecture area, new tools~\cite{aish2012designscript,lopes2011portable} are being proposed to support the \textit{generative design}. A procedural method for generating architectural models~\cite{mccormack2004generative}.

However many of those tools would be unnecessary if the programs were documented properly. The oldest recommended practice in software engineering, i.e. comment the source code, is the most important artifact to understand a system an to maintain it, as showed in~\cite{de2005study}. Unfortunately, for the most programmers, writing documentation is perceived as a tiresome task and thus avoided. This negatively affects software development including the several areas where it is applied. As a result of lack of program documentation, programmers must spend a significant effort to extract relevant ideas from the irrelevant details.

In this work we aim that by creating well designed tools is possible to improve the \textit{program documentation}. We address the problem above, in a way that documenting a program will be no more a tiresome task. Consequently, the program comprehension will be improved because the documentation helps the programmer to create a better mental model. By minimizing the effort to understand a program and enhancing the overall comprehension about the program's structure and behavior.