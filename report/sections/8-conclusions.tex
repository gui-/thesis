%!TEX root = ../report.tex

% 
% Conclusions
% 

\section{Conclusions}
\label{sec:fin}

Programs are rarely released with useful documentation. This negatively affects software development including the several areas where it is applied, particularly in generative design, where programs are becoming relatively complex. It is now important to develop good tools for program documentation and program comprehension.

Base on Learnable~Programming we propose an interactive environment tailored for generative design. This programming environment helps the designer in establishing a strong correlation between the \ac{gd} program, and the geometric sketches that it represents, as a result it eliminates the first barriers to learning, allowing designers to read the code and to understand it at a high level. It also encourages the designer to test his ideas quickly, by seeing the result of his action.

Among the generative design systems which support programming in a textual form~\cite{aish2012designscript,lopes2011portable}, only one~\cite{lopes2011portable} supports other elements, in the editor, besides plain text. However, none of them correlates text with sketches. Moreover, in these systems, the only way to get immediate feedback is using a stepwise debugger which stops the entire program execution and disables editing code.

Using the immediate feedback tool will be possible to edit a \ac{gd} program without stopping its execution. However, similar to what happens with all other generative systems, this tool will not scale for all \ac{gd} programs, due to the render performance of \ac{cad} tools. On the other hand, the code correlation tool requires that the symbols in the sketch to be strictly identified, i.e. get their coordinates in the image to, eventually, point to them. An \ac{ocr} engine is designed for this purpose, however, until now, we had bad experiences to use the \ac{ocr} to recognize handwritten symbols. If necessary, and as a proof-of-concept we will generate the \ac{ocr} data manually.

A functional prototype of these tools was already implemented. We plan to improve this implementation and, if time permits, explore new similar tools, studding possible integrations of these tools in the proposed architecture.

More important than these tools are the underlying design principles that they represent. Understand how these principles enable people to think is the initial step to evolve the way we build programs.