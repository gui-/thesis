%!TEX root = ../report.tex

% 
% Conclusions
% 

\section{Conclusions}
\label{sec:fin}

Programs are rarely released with useful documentation. This negatively affects software development including the several areas where it is applied, particularly in generative design, where programs are becoming relatively complex. It is now important to develop good tools for program documentation and program comprehension.

Based on Learnable~Programming we propose an interactive environment tailored for generative design. This programming environment helps the designer in establishing a strong correlation between the \ac{gd} program, and the geometric sketches that it represents, as a result it eliminates the first barriers to learning, allowing designers to read the code and to understand it at a high level. It also encourages the designer to test his ideas quickly, by seeing the result of his action.

Among the generative design systems which support programming in a textual form~\cite{aish2012designscript,lopes2011portable}, only one~\cite{lopes2011portable} supports other elements in the editor, besides plain text. However, none of them correlates text with sketches, beyond the only way to get immediate feedback is by a stepwise debug which stops the entire program execution, disabling code to be edited.

Using the immediate feedback tool will be possible to edit a program without stopping its execution. However, similar to what happens with all other \ac{gd} systems, this tool will not scale for all \ac{gd} programs, due to the render performance of \ac{cad} tools. On the other hand, the code correlation tool requires that the symbols in the sketch to be strictly identified, i.e. get their coordinates in the image to, eventually, point to them. An \ac{ocr} engine is designed for this purpose, however, until now, we had bad experiences in using the \ac{ocr} to recognize handwritten symbols. If necessary, and as a proof-of-concept we will generate the \ac{ocr} data manually.

A functional prototype of these tools was already implemented. We plan to improve this implementation and, if time permits, explore additional tools, studding possible forms of integrations in the proposed architecture. Table~\ref{ap:planning}, in Appendix A, shows a more detailed plan.

More important than these tools are the underlying design principles that they represent. Understanding how these principles enable people to think is the initial step to evolve the way we build programs.