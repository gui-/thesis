%!TEX root = ../report.tex

% 
% Related work
% 

\section{Related Work}
\label{sec:rw}
A \textit{programming system} has two fundamental parts: the \textit{programming language} that users should know, and the \textit{programming environment} that is installed on the computer. Undoubtedly, both parts are equally important to build a program and understand it.

In the following sections we divide the programming systems in three categories: (\ref{sec:gs}) general-purpose systems; proposed for building complex software, (\ref{sec:ts}) teaching systems; proposed to teach programming, and (\ref{sec:es}) empowering systems; proposed to build programs tailored to specific needs. In each category, we focus on the tools provided by the programming environment.
%%%
\subsection{General-purpose systems}
\label{sec:gs}

The systems in this category are built to support all, or at least a substantial part, of software development process. For this, these systems suggest an \ac{ide} that aims to support the entire development process by grouping in a single environment all necessary tools. These tools are a minimal set of functionality and target all types of programmers (both expert or novices).

In this section we describe, in detail, two popular \ac{ide}s: Eclipse~\cite{carlson2005eclipse} and LightTable\footnote{\texttt{http://lighttable.com/}}. For the sake of comparison, we include other \ac{ide}s which provide similar features to Eclipse (e.g. NetBeans~\cite{boudreau2002netbeans}, IntelliJ~\cite{intellij2001intellij}, and Microsoft Visual Studio (MVS)~\cite{guckenheimer2006software}), and LighTable (e.g. Xcode\footnote{\texttt{https://developer.apple.com/xcode/}}).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Eclipse~\cite{carlson2005eclipse}} is a popular \ac{ide} used mainly by Java developers, although it supports other programming languages such as C, C++ and JavaScript. As showed in~\cite{murphy2006java}, the commonly cited reasons for using Eclipse include rich Java development tools support and a \textit{plugin} architecture, the Eclipse Platform~\cite{DesRivieres2004}, that allows tight integration of third-party functionality.

The Eclipse platform~\cite{DesRivieres2004} has a common architecture among the \ac{ide}s presented in this report. This architecture is characterized by two main components. The \textit{plugin} which is the smallest unit of functionality that can be developed and delivered separately, and the platform runtime which will discover and connect the \textit{plugins} to the platform itself. As a result, the platform integrates several tools that are used in distinct phases of the software development process.

Eclipse has many features that provide feedback to the programmers about what they are constructing, such as syntax highlighting, code completion suggestions, and indications of problems associated with various locations in a source file. In the literature, this concept is also known as \textit{liveness}~\cite{alpern1985defining}. It generally refers to the ability to modify a running program, however, as show in recent studies~\cite{tanimoto2013perspective}, there are several levels of liveness and these tools represent the first ones. While the tools in the first levels respond after a programmer action, the tools in the last levels not only run the program and respond immediately, but also predict the next programmer action. The modern \ac{ide}s tools, such as the Eclipse tools, are far from achieving the last liveness levels.

Moreover, both Eclipse and the other similar \ac{ide}s also share the following drawbacks:
\begin{itemize}
	\item They are incidentally complex. There is an immense amount of work to be done in those \ac{ide}s that is indirectly related to the real problem itself. For example, until the programmer get a simple program to run, he needs to install and configure a set of necessary software, and he needs also to configure the development environment. It is a tiresome and time consuming task that can be difficult even for an expert programmer. It also adds an extra complexity into programming which is already a complex subject.

	\item Programs in these \ac{ide}s are unobservable, such that the only way to see how the program executes is by a stepwise debugger, which forces the programmer to stop the program and look at a line in a single instant of time. Consequently, the programmer cannot see how his program is executing, how his changes affect its execution, nor how his program is connected to others.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{LightTable} is a programming environment which aims to turn programming in a observable task. Bret Victor, in his influential work~\cite{inventingPrin,learnableProg}, pointed out serious problems with the current environments and showed, with some prototypes, how the environment can help to address those problems. LighTable is implemented base on those ideas, and it is designed to build web applications. To support this process, LightTable provides, at least, two useful features: (1) live execution feedback, that executes the program on every change showing the program flow, and (2) the organization of code in tables, enabling quick access to the program documentation.

\begin{figure}[!htbp]
\vspace{-10pt}
  \centering
  \includegraphics[width=1.0\textwidth]{img/lt2}
    \vspace{-20pt}
    \caption{LighTable \ac{ide}.}
    \vspace{-10pt}  
  \label{fig:lt}
\end{figure} 

LightTable is implemented in ClojureScript\footnote{\texttt{http://clojure.org/clojurescript}} (a Clojure compiler that targets JavaScript). Clearly, it is a suitable language for continuous changing and prototyping. For example, a programmer who wants to add a new \ac{ui} element into the programming environment, in LightTable it will be faster than other \ac{ide}s, such as Eclipse~\cite{carlson2005eclipse}. Additionally, ClojureScript's programming model share with Lisp the philosophy \textit{code-as-data}. It provides syntactic transformers (i.e. macros) that expand new language expressions into old ones, but it remains on top of JavaScript.

The program documentation in LightTable is quickly accessed by a lateral tab (as shows Figure~\ref{fig:lt}). Currently, only the primitives functions of Clojure and ClojureScript can be consulted. This documentation is a simple textual description of the function parameters, the kind of return, and usage suggestions. While looking at a program, it is helpful to have the documentation of strange primitives, however non-primitive functions are still undocumented. 

\begin{wrapfigure}{r}{0.3\textwidth}
  \vspace{-25pt}
  \begin{center}
    \includegraphics[width=0.3\textwidth]{img/eval-close}
  \end{center}
  \vspace{-20pt}
 \caption{LightTable real-time debugger.}  
  \vspace{-20pt}
    \label{fig:lt2}
\end{wrapfigure}

On the other hand, programmers are encouraged to understand new functions by seeing how the values of a function call flow through it. This feature is based on the old idea of Lisp environments, the \ac{repl} which is a prompt used to try out expressions of the language without having to run all the code. This approach goes further by using reflection mechanisms to trace the function call values and shows them filled in a template. Figure~\ref{fig:lt2} shows the flow of values produced by calling \texttt{(x 3 7)}.

The real-timer debugger is an interactive way to debug the code and understand the program flow. Using this feature in an arbitrarily complex program (a program with more than 30 functions) is, however, worthless, because, all the programmer sees is a replica of his functions filled with numbers. It is a poor representation of flow which forces the programmer to spend as much effort with this feature as without it. For this reason, other systems, described in this report, represent the program flow using flow graphs which are more appropriate in some cases, for example, to show a flow graph of an error occurrence. 

Despite of providing some tools which are state of the art, LightTable remains in an experimental phase. It has serious limitations to identify and clearly present the errors to the programmers. This problem is, mainly, related with the Clojure compiler which is a recent technology and lost significant \textit{metadata} between conversions. Consequently, programmers can spend more time and effort to find a bug using LighTable, than using the presented \ac{ide}s.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Teaching systems}
\label{sec:ts}

Unlike the previous systems, these systems are designed with the goal of helping people learning to program. Most of the systems in this category provide simple programming tools that expose the novice programmers some of the fundamental aspects of the programming process. After acquiring experience with a teaching system, students are expected to move to a more general-purpose environment. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{LOGO~\cite{papert1980mindstorms}} is a programming language and environment intended to allow children to explore a wide variety of topics such as physics and mathematics. The programming language is a dialect of Lisp, with much of the punctuation removed to make the syntax accessible to children. Indeed, the notorious LOGO's innovation is the metaphor that the programming language represent.

\begin{wrapfigure}{r}{0.35\textwidth}
  \vspace{-15pt}
  \begin{center}
    \includegraphics[width=0.35\textwidth]{img/turtle}
  \end{center}
  \vspace{-20pt}
 \caption{Directing the ``turtle''.}  
  \vspace{-20pt}
    \label{fig:turtle}
\end{wrapfigure}

In Logo, the programmer draws pictures by directing the ``turtle'', an onscreen character which leaves a trail as it moves (Figure~\ref{fig:turtle}). The turtle serves a number of functions, but the most important is that the programmer can identify with it. That means, to figure out how to make the turtle perform an action, the programmer can ask how he would perform that action himself, as if he were the turtle.

For example, to figure out how to draw a circle, a learner would walk around in circles for a bit, and quickly derive a ``circle procedure'' of taking a step forward, turning a bit, taking another step forward, turning a bit. After teaching it to himself, the learner can then teach it to the computer. The turtle is the in-computer embodiment of the programmer himself, a self, like the player-character in a video game, and thereby allows the learner to transfer his knowledge of his own body into knowledge of programming.

LOGO has influenced several systems, and its principles show how a system can be designed around the way people think and learn.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{SmallTalk~\cite{Kay1993}} is a programming language and environment to support children in the world of information. The designers of this system wanted to create a programming language that had a simple model of execution and a programming methodology that could accommodate a wide variety of programming styles. SmallTalk was based around three ideas: (1) everything is an object, (2) objects have memory in the form of other objects, (3) and objects can communicate with each other through messages.

Like LOGO, the communication through messages has a strong resonant metaphor. To specify the behavior of an object, the programmer casts himself into the role of that object (to the extent of referring to the object as ``self'') and thinks of himself as carrying on a conversation with other objects. This is a strong metaphor, because role-playing and conversing are innate human facilities. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Processing~\cite{Reas2006}} is a programming language and environment designed to teach programming, aided by a visual context. Processing has become popular among students, artists, designers, architects, and researchers, because it acts as a tool to get non-programmers started with programming through the instant visual feedback. Consequently, a new programming language and environment were tailored around this purpose.

The programming language is built on top of Java, but it removes the much of the verbosity of Java to make the syntax accessible to novices. The language provides simple access to external libraries, such as OpenGL, through single entry points, such as \texttt{setup} and \texttt{draw}. This allows novices to quickly prototype, learn fundamental concepts of programming, and, eventually, gain the basis to learn other programming languages.

The programming environment contains a simple text editor, a text console to present errors, and a run button. The run button compiles the Processing code and executes it. Despite in the default mode the result is presented in a 2D graphical window, the render can be configured to present the result in 3D or in other sophisticated method to use \textit{shaders} to recur directly to the graphic board.

Actually, with a few changes, the Processing code can be exported as an application for different platforms, such as Java, JavaScript, and Android. For example, to export a Processing program for JavaScript, it is only necessary to create a new HTML page and include the Processing code as a script of this page. Then the Processing code will be automatically parsed and translated to JavaScript. To maintain the usual render capabilities of a Processing program it will use the HMTL5 canvas with WebGL.

The popularity of Processing is explained by the benefits of these features, besides it is a domain-specific language, however it has drawbacks that can discourage the learning in general, such as the following:

\begin{itemize}
  \item \textit{Weak metaphor}. In Processing, by contrast with the above systems, the programmer has no identity within the system. There are no strong metaphors that allow the programmer to translate his experiences as a person into programming knowledge. 

  \item \textit{Poor decomposition}. Processing discourage the fundamental approach to solve a complex problem by breaking it into simpler problems, because drawing and input events are tied to single entry points. Thereby the behavior of submodules must be tangled across these global functions. Clean decomposition is not possible.

  \item \textit{Poor recomposition}. Processing discourage combining two programs. The programmer cannot just grab and use part of other programs, because variables must be renamed or manually encapsulated, and the \texttt{draw} and mouse functions must be woven together. Even worst, Processing has global modes which alter the meaning of the function arguments. For example, two Processing programs can specify its colors in different modes and each mode has its proper meaning of \texttt{fill} function arguments. Combining those programs will be almost impossible. 

  \item \textit{Weak readability}. The syntax of a Processing program represent a significant barrier for reading. For example, the function which draws an ellipse on screen is written as \texttt{ellipse(50,50,100,100)}. The reader must lookup or memorize every single argument.

  \item \textit{Fragile environment}. The programming environment is fragile, because it does not attempt to solve any of the above issues related with the language and its implementation.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Fluxus\protect\footnote{\texttt{http://www.pawfal.org/fluxus/}}} is a programming language and learning environment designed for rapid prototype using 3D graphics and sounds. This emphasis on rapid prototype and quick feedback make Fluxus a tool for learning computer animation, graphics and programming. However, the most users of Fluxus use it for \textit{livecoding} which is the act of performing coding lively to an
audience.

Fluxus is mainly written in C++ and it is statically linked to several shared libraries, specified at compile time. For instance, Fluxus uses \texttt{jack-audio, ode, fftw} libraries to handle and synchronize the audio, \texttt{GLEW} to present graphics and \texttt{racket3m} to embed the Racket run-time system into the application. In this way, Fluxus programming language is an extension of Racket (a descendant of Scheme) with graphical commands. 

Like Processing, Fluxus provides simple access to those libraries through single entry points, for instance \texttt{start-audio} connects an input audio to the application, \texttt{every-frame} register a function called once per frame, and so on. However, as stated above, it is a barrier for decomposition since the behavior of submodules must be tangled across these global functions.

Fluxus has its own environment specifically tailored for \textit{livecoding}. It is composed by a OpenGL graphical window with a simple text editor. The programmer types his code in the editor and press a shortcut key each time he wants to run the code. Fluxus evaluates the code through Racket run-time system and shows its result in the same graphical window that the code was written. This mechanism is valuable in an \textit{livecoding} environment, because the performer can be editing the code while the result of the previous computation is maintained at background. However, if the code has any error and the performer execute it, the previous computation disappears and the environment will not help to find it. This is a serious problem, specially for the Racket syntax.

Moreover, Fluxus share with Processing the similar drawbacks previously stated. However Fluxus can be used as a module of DrRacket~\cite{findler2002drscheme} programming environment. Fortunately, in DrRacket the above problem and many others are solved.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{DrRacket~\cite{findler2002drscheme}} is a programming environment designed to overcome the problems related with the Racket language and its implementation. DrRacket is one of few programming environments which supports gradual learning in a more general language from the start. Consequently, it has been widely used in introductory programming courses for several universities around the world.

The usual scenario where DrRacket is used is to teach functional programming using Racket. To facilitate this process DrRacket provides three tools. The first is a symbolic stepper. It models the execution of Racket programs as algebraic reductions, since Racket is implemented on top of lambda calculus. The second tool is a syntax checker. It annotates programs with font and color changes based on the syntactic structure of the program. It also permits students to explore the lexical structure of their programs graphically and to $\alpha$-rename identifiers. The third tool is a static debugger that infers what set of values an expression may produce and how values flow from position to position in the source text. And, upon demand, it explains the reason of errors by drawing value flow graphs over the program text.

Similar to the lisp environments, DrRacket provides a read-eval-print loop (\ac{repl}). It is a command prompt intended to quickly execute expressions and print its output. Specially in a learning environment this feature makes an important connection between program execution and algebraic expression evaluation. However the Lisp-style syntax obscures the effect of this feature. To overcome this limitation, DrRacket provides a \texttt{pretty-printer}. A module capable of printing algebraic expressions in a meaningful way, as well as other graphics elements supported by the text editor, such as images, snips, XML boxes, and so on.

From the perspective of professional programmers DrRacket can be a potential target. It is useful for developing complex applications, including the DrRacket itself. Moreover it is extensible by the same \ac{api} which actually the above tools implement. Through this \ac{api} is even possible to extend the \ac{repl}, as in Pict3D\footnote{\texttt{https://github.com/ntoronto/pict3d}} (a 3D engine that integrates new graphical elements in the DrRacket environment). On other hand, to support this kind of extensions, among others, DrRacket's architecture has become increasingly complex. For instance, to make a simple change in a editor's element the programmer should be able to understand several modules, unrelated with the problem itself. This extra complexity is perhaps a negative impact when DrRacket is chosen as a basis for new develop tools.

Despite of the identified advantages, DrRacket has some barriers that may discourage the learner. For example, the Racket programming language is simple to teach. But its heavy syntax of s-expressions hinders the learner to read the program. Consequently, he cannot concentrate on what is really genuine, spending a huge mental effort to understand insignificant details of the language.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{PythonTutor~\cite{GuoSIGCSE2013}} is a web-based program visualization tool, designed to explain how a piece of Python code executes. It has become popular among students from introductory Computer Science courses. Using this tool, teachers and students can write Python programs directly in the web browser and navigate step by step throughout its execution, seeing the run-time state of data structures. For example, a global variable that defines a tuple will be represented with an arrow that point to a box with two divisions.

PyhtonTutor has two main modules: the \textit{backend} which implements the tool core functionality and the \textit{frontend} which presents the visualization of program's data structures. The \textit{backend} executes the input program under supervision of the standard Python debugger module (\texttt{bdb}) which stops execution after every executed line and records the program's run-time state. After execution terminates, the \textit{backend} encodes the trace in JSON format, serializing Python data types into native JSON types with extra \textit{metadata} tags and send it to the \textit{frontend}. The frontend renders the objects using standard web technologies: HTML, CSS, and JavaScript. In this way, users can use the tool without installing any extensions or plugins.

A major concern in PythonTutor is the security, because the PythonTutor's \textit{backend} executes untrusted Python code from the web. To prevent the execution of dangerous constructs such as {\tt eval}, {\tt exec} and {\tt file I/O}, PythonTutor implements sandboxing. Basically, it denies the use of most module imports, by parsing the user's code importing. A strict approach, but effective in this case.

The PythonTutor tool allows the programmer to follow the program execution over time. But, he only sees a single point in time at any instant. There is no visual context at all. The entire program flow is represented by disconnected points in time. For example, the programmer who wants to understand a conditional algorithm, using this tool will not see the pattern of this algorithm neither understand it at a higher level.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{YinYang~\cite{mcdirmid2013usable}} is a prototype of a programming language and environment whose main feature is the live execution feedback. That means it combines editing and debugging, where updated debug results are conveniently visible while editing. YingYang addresses the above issue in two ways. First, as well as the previous system, it allows programmers to see single points of execution directly within the code editor (probe; precede expressions with \texttt{@} operator). Second, it has a pane aside the editor which traces execution with entries that are navigable (trace; print-like statements). Basically, the trace is an enhanced display function which combined with ``probes'' allows the state of previous executions to be restored. So, programmers can take in the entire program flow at a glance and navigate trough it using probes.

YingYang uses an incremental framework as basis of its programming model. This framework decomposes the program execution into a tree of nodes that can be re-executed independently on a code or input change. However, this decomposition cannot be performed transparently. It requires programmers to specify how the program will be decomposed. To perform this task one must deeply understand the granularity and modularity characteristics of the computations being performed by the program. Otherwise changes can sometimes have a huge impact on program re-execution time ($\sim$50ms). Consequently, live programming would actually reduce programmer productivity as programmers depend on but wait for slow feedback.

Although YinYang provides usable features for a learning environment, such as the live execution feedback, it does not have a suitable language for beginners. The language is merely experimental as well as the system. Moreover, to navigate through the program execution programmers must include probes in the code. At the end of experimentation the code is full of useless expressions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
\subsection{Empowering Systems}
\label{sec:es}

The systems in this category are built with the belief that the important aspect of programming is that it allows people to build things that are tailored to their own needs. In this section, we describe how systems from two distinct areas are being tailored to achieve their user's needs. 

First, in Architecture where new programming languages and environments are being proposed to support the increasing use of \ac{gd}~\cite{mccormack2004generative}. The \ac{gd} is a design method that uses algorithms to generate architectural models. Usually these models are rendered using a \ac{cad} tool. 

Second, in Mathematics where advanced technologies are being used to approximate as much as possible the mathematical models to ones that we can see and understand.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{DesignScript~\cite{aish2012designscript}} is a programming language and environment designed to support \ac{gd} with textual methods. It is mainly used by architects and designers to generate geometric models for AutoCAD. Instead of creating geometric models manually by manipulating \ac{ui} icons, designers can automate this process with a script. When the script is executed a geometric model is generated in AutoCAD. The Figure~\ref{fig:ds}, shows five spheres, in a 2D view, being created using this method.

\begin{figure}[!htbp]
\vspace{-5pt}
  \centering
  \includegraphics[width=1.0\textwidth]{img/designScriptIDE}
  \vspace{-20pt}
    \caption{DesignScript programming environment.} 
    \vspace{-10pt} 
  \label{fig:ds}
\end{figure} 


\begin{wrapfigure}{r}{0.4\textwidth}
  \vspace{-25pt}
  \begin{center}
    \includegraphics[width=0.4\textwidth]{img/designscript}
  \end{center}
  \vspace{-20pt}
 \caption{Associative interpretation.}  
  \vspace{-20pt}
    \label{fig:designscript}
\end{wrapfigure}

The programming language is presented as an associative language. The variables are abstract types that can represent numeric values or geometric entities. These variables are maintained in a graph of dependencies. When a change in a variable occurs it forces the re-evaluation of the graph, as shows Figure~\ref{fig:designscript}. Consequently, a subsequent change to a variable has impact on its previous use. This feature is useful, specially in a modeling environment, because it provides continuous feedback to the designer as new models are added.

The DesignScript's programming environment provides a text editor coupled into AutoCAD, an interpreter, a simple debugger and few tabs on the bottom. The language interpreter is invoked each time that the designer clicks on the run button. Then all the script is interpreted and its result produces geometric entities rendered in the \ac{cad}. The continuous feedback feature works only in debug mode, because in this mode the script is interpreted line by line. Thus each set to a variable will change its dependencies and will recompute the model. However, in debug mode the code cannot be edited. Consequently, this feature is worthless during code editing.

In the DesignScript's debug mode, users can inspect the variable values by adding \textit{watchers} to them. A watched variable is showed in a special tab, as shows Figure~\ref{fig:designscript}. In case of the variable represents a geometric model, the respective model will be highlighted in the \ac{cad} when the variable is selected. It creates a certain \textit{traceability} between models in the \ac{cad} and code in the editor. In this way he user is able to correlate which model a variable correspond. However the inverse, starting form the model and find the correspondent variable, is unsupported.

DesignScript also supports the typical mechanism of \textit{live} programming environments: the sliders. The sliders are widget which facilitate to give new values to the program input. By quickly experiment new ideas, designers can create new models reacting by these changes. However, in the DesignScript's sliders the changes just reflect in the models when the designer drops the slider. Until there, the designer should imagine how would be the model with the dragged value. It is completely against the purpose of the sliders.

Moreover the DesignScript language, despite of being presented as pedagogic, has some drawbacks. It does not carries any strong metaphor which helps beginners to start with the language. Additionally the associative paradigm represents an barrier for sharing code. Because it discourages the recomposition of modules, since new modules can change the previous one. The environment provides poor mechanism that help people to find bugs in the code. And finally, a DesignScript is confined to only produce geometry to AutoCAD.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Monkey\protect\footnote{\texttt{http://wiki.mcneel.com/developer/monkeyforrhino4}}} is a programming environment designed to support \ac{gd} with textual methods. Like DesignScript Monkey is used to edit, debug and interpreter scripts. However Monkey uses RhinoScript as its programming language and Rhinoceros3D\footnote{\label{rhin}\texttt{https://www.rhino3d.com}} (or Rhino for short), a lighter \ac{cad} than the AutoCAD, to generate the geometric models.

Monkey is implemented as a plugin for Rhino4. It uses a \texttt{.NET} framework to communicate with the \ac{cad}. So the scripts are written outside of the \ac{cad}'s environment and upon execution the plugin, through the framework, invokes the \ac{cad} primitives to generate the models. It has an advantage, relatively the previous system, which is the \ac{cad} independence. On the other hand, it depends on the \texttt{.NET} framework which must exist in the user's machine.

In fact, Monkey is pretty based on general-purpose environments. It provides typical features of those environments, namely syntax highlighting, auto-completion and error highlighting. And even the organization of code into trees are similar. However, this influence seems awkward when the community that will use these tools are mostly composed by beginners in programming. Moreover, similar to DesignScript, the RhinoScript just produce geometry for Rhino. Consequently Monkey is also \ac{cad} dependent. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Rosetta~\cite{lopes2011portable}} is a programming environment designed to support \ac{gd} with textual methods. Like Monkey, Rosetta provides its own environment detached from the \ac{cad}. Rosetta is a step forward from the previous systems, because it solves the portability problem among \ac{cad}s. In Rosetta a \ac{gd} program can be written in various programming languages (frontends) and the geometric models can be rendered by various \ac{cad}s (backends). As a result, designers are free to write their programs in their preferred frontend which, upon execution, will generate the same geometry for the various backends. In Figure~\ref{fig:rosetta}, a program is written in Racket and its execution produces geometry for AutoCAD.

\begin{figure}[!htbp]
\vspace{-5pt}
  \centering
  \includegraphics[width=1.0\textwidth]{img/rosetta1}
  \vspace{-20pt}
    \caption{Rosetta programming environment.}  
  \label{fig:rosetta}
  \vspace{-10pt}
\end{figure} 

Rosetta has been used to teach programming in an architecture course. Tailored to this end, Rosetta uses DrRacket~\cite{findler2002drscheme} as its own programming environment. The DrRacket environment serves a number of functions, but the most important is that the student can start immediately to learn programming. For instance, the environment is set up with just three lines of code. As shows Figure~\ref{fig:rosetta}, the \texttt{\#lang} specifies the frontend language, the \texttt{require} imports Rosetta's primitives and finally the \texttt{backend} names a possible backend.

The Racket language is also an advantage of Rosetta's environment. Because, mainly, it encourages the development of the mathematical paradigm for writing algorithms. In this way, students that learn simple programming techniques, such as recursion, are able to create robust models as never designed before. Additionally, as the students progress, new programming languages are also available to learn, such as JavaScript, Python, Processing and so on.

The Rosetta's environment provides some interesting tools for \ac{gd}. A programming flow tracer, similar to the DesignScript's watcher. It highlights models in the \ac{cad} upon function selecting. However this feature goes further, it highlights the code in the editor upon model selecting. Another interactive tool is the slider. An attempt to provide immediate feedback to the designers. The slider's callback is the function that generates the entire model, so each time the slider change this function will be called. Consequently a new model will be generated.

Undoubtedly Rosetta's environment goes further than the textual environments for \ac{gd} presented in this report. However it presents some drawbacks which may discourage the learning in general. Beginning with the usual programming language: Racket. The syntax of a Racket program represents a significant barrier for reading. For instance the function which draws a circle in Rosetta is written as \texttt{(circle (xy 0 0) 1)}. The reader must lookup or memorize every argument. Using the Rosetta's documentation the reader will spend even more time, because it is in a book mixed with architecture subjects. Moreover, the immediate feedback confines to re-execute the same function with different arguments.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Grasshopper\protect\footnote{\texttt{http://www.grasshopper3d.com/}}} is a programming language and environment designed to support \ac{gd} with visual methods. Grasshopper provides an alternative way to programming. By definition, it is a bi-dimensional representation consisting of iconic components that can be interactively manipulated by the user according to some spatial grammar~\cite{myers1990taxonomies}. For example, the boxes in Figure~\ref{fig:grass} are components which receive the input (left ports) perform some operations and return the output (right port). The components are linked to other components establishing a \textit{dataflow} paradigm where the input of a component is the output of another.

\begin{figure}[!htbp]
\vspace{-5pt}
  \centering
  \includegraphics[width=0.8\textwidth]{img/grasshopper}
  \vspace{-5pt}
    \caption{A program in Grasshopper that computes the 3D coordinates of a conical spiral. Each time the left sliders are dragged a new coordinate is calculated.}
  \label{fig:grass}
  \vspace{-10pt}
\end{figure}

Like Monkey, Grasshopper is implemented as a \textit{plugin} for Rhino\footnotemark[\ref{rhin}]. However Grasshopper tailors the Rhino's environment with specific \ac{gd} tools. These tools are state of the art, because they implement important principles for design models, such as the following:

\begin{itemize}
 \item \textit{Get immediate feedback}. As the user interacts with the components, by adding and connecting them, the result reflects immediately in the \ac{cad} model. It facilitates the design conception, because the user's intentions are immediately visible. 
 \item \textit{Facilitate program input}. To facilitate the process of design exploration, Grasshopper provides sliders which are connected at the component input. Dragging the slider causes a change propagation through components. The components are re-executed with the new slider value. Combined with the above feature new models are generated immediately.
 \item \textit{Correlate the program with generated elements}. Like DesignScript's watcher, by selecting a component its geometry is highlighted in the \ac{cad}. It allows designers to better understand a program by figuring out the roles of each component.
 \item \textit{Show comparisons between models}. Grasshopper provides a special component that, when connected at the output of another component, replicates the geometry. This mechanism is useful for design exploration, because it maintains in the \ac{cad}'s background an old replica of the changed geometry. It adds a context at each change, so the designer can compare the result of his change in the new geometry based on the old one.
\end{itemize}

Mainly, the Grasshopper interactivity depends on the immediate feedback tool. However, this tool will never scale for arbitrarily complex programs. Because the \ac{cad}'s render is not designed to process the huge amount of information generated by \ac{gd} methods. Other systems, such as DesignScript and Rosetta, improve this problem by sidestepping most of the functionality of traditional \ac{cad} tools and focusing only on the generation and visualization of geometric models. So these systems provide a backend based on OpenGL that is independent of a full-fledged \ac{cad} application. But in Grasshopper there is no such backend.

Moreover, the traceability among components is just in one direction. From the designer perspective, would be more useful to start form the geometry and find which component implements it. However this is unsupported. And despite the comparison between models be useful in design exploration. To use this feature requires the designer to have a deeply understanding of the program, or at least knows the main program \textit{dataflow}. Unlike this approach, this feature should be available whenever a change in the model occurs.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Dynamo\protect\footnote{\texttt{http://dynamobim.com/}}} is a programming language and environment designed to support \ac{gd} with visual methods. Like Grasshopper, Dynamo provides an alternative way to programming. However Dynamo is implemented on top of Revit an Autodesk product for \ac{bim}. In short, a \ac{bim} model is similar to a \ac{cad} model but it covers more than just geometry. It also covers spatial relationships, properties of building components, such as manufacturers' details, and so on. Consequently, a \ac{bim} model is more straightforward to reproduce than a \ac{cad} model. 

\iffalse
\begin{figure}[!htbp]
	\vspace{-15pt}
	\begin{center}
  		\includegraphics[width=0.8\textwidth]{img/dynam-tab}
   	\end{center}
   	\vspace{-15pt}
    \caption{Dynamo search tab.}
  \label{fig:dynam}
\end{figure}
\fi

\begin{wrapfigure}{r}{0.6\textwidth}
  \vspace{-10pt}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{img/dynam-tab}
  \end{center}
  \vspace{-20pt}
 \caption{Dynamo search tab. Searching for a component, highlighted in red.}  
  \vspace{-15pt}
    \label{fig:dynam}
\end{wrapfigure}

Dynamo provides a set of tools similar to Grasshopper, particularly it provides a searching table as shows Figure~\ref{fig:dynam}. This lateral table provides quick access to the primitives of the language, such as the components and widgets. This feature encourages designers to explore the available components and try new components never ever tried.  

In general, Dynamo and Grasshopper are programming environments and visual languages popular among novices in programming. The smooth learning curve and perhaps the style of the \ac{ui} elements are attractive for beginners. However as the visual programs become large and complex it requires more time to understand, maintain, and adapt to new requirements, than the textual programs as showed in~\cite{leitao2011programming}. Despite of spending more time and effort to learn a textual programming language, the learners have their time quickly recovered once the complexity of the design task becomes sufficiently large.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Mathematica~\cite{wolfram1991mathematica}} is a language and environment built to support scientific calculation. It is widely used in the scientific community, specially by students, because it is an artificial language in which typical computations and programs are expressed in the shortest and clearest possible way. For this, Mathematica supports not just liner textual input, but also full two-dimensional input, like traditional mathematical notation, as shows Figure~\ref{fig:math}.

\begin{wrapfigure}{r}{0.6\textwidth}
  \vspace{-35pt}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{img/mathematica}
  \end{center}
  \vspace{-23pt}
 \caption{Mathematica program. Note the two-dimensional character of the input.}  
  \vspace{-25pt}
    \label{fig:math}
\end{wrapfigure}

The core concept of Mathematica as such a language was based in the paradigm initiated by Turing's work~\cite{wolfram2003wolfram}. In this paradigm mathematical processes are systematized as computations. As a result, Mathematica represents mathematics by finding what is true explicitly computing output from input. 

Mathematica can internally represent any possible computation. The challenge it addresses is to connect those possible computations to ones that human can describe. Surprisingly to achieve this, it took only a modest set of innovations. Because there was a certain degree of consistency in the way notation tended to be used. As a result, the main process it implements is converting this notation to something completely precise and computable. 

Presenting the information in a human readable form is, undoubtedly, a successful strategy of Mathematica's features. However the growing complexity of these features may overwhelm some novices. For this reason, Mathematica is avoided in many subjects. Mainly because it adds an extra level of complexity in a subject that is already difficult. On the other hand some mathematicians, and some students, seem to get so fascinated with these tools that the mathematics ends up relegated to a supporting role.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{IPython~\cite{PER-GRA:2007}} is a programming environment built to support scientific calculation. Originally, IPython was designed to be a mini Mathematica~\cite{wolfram1991mathematica}. Nowadays it supports a set of languages (frontends) and provides, among other features, an interactive shell and a browser-based notebook with support for code, text, mathematical expressions, plots and other rich media. 

\begin{wrapfigure}{r}{0.6\textwidth}
  \vspace{-35pt}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{img/ipython-zoom}
  \end{center}
  \vspace{-25pt}
 \caption{IPython browser-based notebook. The input is just linear characters.}  
  \vspace{-15pt}
    \label{fig:ipython}
\end{wrapfigure}

IPython is implemented in Python to get access to the several libraries of math computation. Like Mathematica, a program in IPython explicitly computes an output from input. It is an useful paradigm for developing iteratively, because a program can be written in parts and each part is tested individually. However, IPython is focused on interoperability rather than present its computations to ones that humans can describe.


Figure~\ref{fig:ipython}, shows some interactions with the IPython notebook using Python language through a web browser. The IPython architecture is a kind of client-server. The frontend language is the server and the notebook is the client. To support several frontends IPython provides a base layer for new programming environments. This layer exposes the major components of IPytohn's architecture. Consequently, IPython's features are available form others systems. For example, IJulia uses IPython interface with Julia language. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{MathCAD\protect\footnote{\texttt{http://www.ptc.com/product/mathcad}}} is a programming environment and language built to support scientific calculation. Like Mathematica, MathCAD aims to present information into a human readable form. However, it generates live calculations with graphical plots, text and images into a single document. This document is the program environment as well as the final product.

The mathematical expressions defined in the MathCAD document act as an associative language. So when a expression is changed its value is propagated through the document. This mechanism is the base of the interactiveness. However, as stated above, it represents an barrier for recomposition. Because new expressions can change the previous one. Moreover, the MathCAD language is purely visual consequently it presents the same drawbacks identified above.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		     

%%
\subsection{Summary}

Table~\ref{tab:sum} attempts to show the presented systems based on their major design influences. The table is also intended to address the following questions.

\begin{table}[h]
\vspace{-10pt}
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{@{}clllcl@{}}
\toprule
\multicolumn{1}{l}{\textbf{Type$^{(1)}$}} & \textbf{System} & \textbf{Main feature}$^{(2)}$ & \textbf{\begin{tabular}[c]{@{}l@{}}Support to under-\\ stand programs$^{(3)}$\end{tabular}} & \multicolumn{1}{l}{\textbf{\begin{tabular}[c]{@{}l@{}}Representation \\ of code$^{(4)}$\end{tabular}}} & \textbf{\begin{tabular}[c]{@{}l@{}}Construction\\ of programs$^{(5)}$\end{tabular}} \\ \midrule
\multirow{6}{*}{GS} & Eclipse & \multirow{4}{*}{\begin{tabular}[c]{@{}l@{}}support software\\ development \\ life cycle\end{tabular}} & \multirow{4}{*}{debugger} & \multirow{16}{*}{text} & \multirow{16}{*}{typing code} \\
 & NetBeans &  &  &  &  \\
 & IntelliJ &  &  &  &  \\
 & MVS &  &  &  &  \\ \cmidrule(lr){2-4}
 & Xcode & \multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}observable \\ programming\end{tabular}} & \multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}live execution\\ feedback\end{tabular}} &  &  \\
 & LightTable &  &  &  &  \\ \cmidrule(r){1-4}
\multirow{7}{*}{TS} & LOGO & \multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}understandable\\ language\end{tabular}} & \multirow{2}{*}{physical interpretation} &  &  \\
 & SmallTalk &  &  &  &  \\ \cmidrule(lr){2-4}
 & Processing & \multirow{2}{*}{visual context} & \multirow{2}{*}{instant visualization} &  &  \\
 & Fluxus &  &  &  &  \\ \cmidrule(lr){2-4}
 & DrRacket & gradual learning & debugger; stepper &  &  \\ \cmidrule(lr){2-4}
 & PythonTutor & \multirow{2}{*}{show program flow} & \multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}navigate through the \\ program execution\end{tabular}} &  &  \\
 & YinYang &  &  &  &  \\ \cmidrule(r){1-4}
\multirow{8}{*}{ES} & DesignScript & \multirow{3}{*}{\begin{tabular}[c]{@{}l@{}}support\\ generative\\ design methods\end{tabular}} & \multirow{3}{*}{debugger} &  &  \\
 & Monkey &  &  &  &  \\
 & Rosetta &  &  &  &  \\ \cmidrule(l){2-6} 
 & Grasshopper & \multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}alternative way to \\ expressing programs\end{tabular}} & \multirow{2}{*}{dataflow paradigm} & \multicolumn{1}{l}{\multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}graphical \\ components\end{tabular}}} & \multirow{2}{*}{\begin{tabular}[c]{@{}l@{}}linking\\ components\end{tabular}} \\
 & Dynamo &  &  & \multicolumn{1}{l}{} &  \\ \cmidrule(l){2-6}
 & Mathematica & \multirow{3}{*}{\begin{tabular}[c]{@{}l@{}}support \\ scientific calculation\end{tabular}} & \multirow{3}{*}{\begin{tabular}[c]{@{}l@{}}present data \\ meaningfully\end{tabular}} &  \multicolumn{1}{l}{\multirow{3}{*}{\begin{tabular}[c]{@{}l@{}}mathematical\\ forms\end{tabular}}} & \multirow{3}{*}{fill forms} \\
 & IPython &  &  & \multicolumn{1}{l}{} &  \\
 & MathCAD &  &  & \multicolumn{1}{l}{} &  \\ \bottomrule
\end{tabular}
}
\vspace{1pt}
\caption{System Attributes.}
\vspace{-15pt}
\label{tab:sum}
\end{table}

(1) \textit{What is the purpose of the system?} We categorized three main purposes which a system can be designed. \ac{gs} designed for building complex software for the industry. \ac{ts} designed to help people learn to program. \ac{es} designed to allow people build things that are tailored to their own needs.

(2) \textit{How does the system support its purpose?} We identified the following strategies. (i) Support software development life cycle, (ii) turn programming in something more observable, (iii) create an understandable language, (iv) combine textual programming with a visual context, (v) support gradual learning in a single environment, (vi) show the program flow, (vii) support generative design methods, (viii) find alternative ways for typing programs and (ix) support scientific calculation.

(3) \textit{Does the programming environment provide additional support to enable users to better understand the behavior of their programs?} Environments in our study used several techniques to help users understand the behavior of their programs. These included (i) a debugger which helps to find bugs in the program, (ii) an enhanced debugger which provides live execution feedback, (iii) languages with strong metaphor allowing physical interpretation, (iv) instant visualization of models, (v) navigation through the program's execution (vi) assembling components in a dataflow paradigm and (vii) present data as humans understand.

(4) \textit{How does code look in the programming environment or language?} The systems in our study represent programs using text, graphical components, users can manipulate, and mathematical forms users can fill in.

(5) \textit{What actions do users take to construct programs?} Users can construct programs by typing code, linking graphical components and editing mathematical forms.

To conclude, in the surveyed systems the common representation of code is textual. This representation is typically static and, to be understood, requires the reader to know the vocabulary of the programming language. For a novice it is simply a barrier to learning. On the other hand, the representation of programs as a graphical components or mathematical forms eliminates this barrier, because it is easier to read, but it becomes incomprehensible as the program grows.