Dissertation Outline

Introduction
	-describe the problem

Related Work

Methodology
	-describe the decisions made
		-why choosing DrRacket?
		-why implement those two features?
	-describe the work
		-image-code
			-OCR
			-string
			-comments
		-auto-run
			-inspection trace
	-introduce evaluation

Evaluation

Conclusion

================
Effective Programming System for Generative Design

	what is this chapter about?
	introduce the ideas that this thesis will implement

	what issue is this chapter addressing?
	define theoretically what is the solution for the problem

	how does this chapter fit within the overall story of the thesis?

	----beginning
	-restating the problem
		-GD area is becoming popular but is lacking decent environments to introduce programming for new users
			-current GD environments are old or obsolete
			-they enforce inadequate programming methods
			-they are not pedagogic
		-GD programs is becoming complex and there is no tools to deal with it
	
	-requirements of a programming system for GD
		-main NFQ for GD systems: portability, usability, performance and documentation
			-usability applied to the overall system

		-portability
			-Portability is a software requirement of the utmost importance because it is a key factor for software reuse.
				-software reuse - explain
				-survival factor for small and medium-sizes programmer communities
			-Example the processing/python communities
				-online collection of software and documentation
			-portability and re-usability are qualities that allow software to adapt to new environments
				-example if Rhinoceros 3D change its programming language, the Rhinoscript program becomes useless
				-user either: discard the program or rewrite them in a supported language
				-both are inadequate
			-programs written in the programming language of a particular CAD application are not portable across the majority of others
				-strong coupling between a program and a CAD application
					-dangerous to the survival of the program
					-damages the software process productivity, quality and communities
			-in the same way there is a strong coupling between the programming environment and the programming language
				-users are locked-in to one family of CAD applications 
					-because their programs are one compatible with 
					-that particular environment 
					-that particular language
					-that particular CAD application

		-interoperability
			-interoperability refers to the ability of systems to usefully exchange information.
				-exchange data (syntactic interoperability)
				-interpret the data (semantic interoperability)
				-a system cannot be interoperable in isolation that means 
				 interoperability is affected by the systems expected to operate. 
			-GD system is expected to operate with CAD application
				-by APIs to access CAD functionality
				-as well defined is the API as better systems will exchange useful information
					-some cad functionality are hidden
					-heterogeneity among CAD applications
			-parametric elements supported in visual context but not in textual
				-operations such as sweeping an geometric object in a curve
			-functional operations
				-arithmetic operations with geometric shapes
				-highlight the errors
			-dimension independent operations
				-non-uniform treatment of shapes
				-difficult to write generic programs
			-algebra of set
				-empty intersection results in an error
					-do not implement the concept of empty or universal set
			-algebraic equivalence
				-basic algebraic equivalence is invalid in several CAD applications
				(1) the actual performed combination of Boolean operations can be difficult to predict;
				(2) a program that only runs in the CAD application that supports one particular combination is not
				portable; and (3) adapting a program to use only the combinations of Boolean operations supported by
				a CAD application might require extensive changes.

		-performance
			-It's about time.
				-short introduction
			-CAD applications were designed to process commands introduced at human speed
				-graphical user interface centric
					-commands are mainly through GUIs
					-drag and drop to create new geometric objects
			-to build considerable project user may spend months
				-complex GUI to provide all functionalities
			-GD methods allow CAD commands to be introduced at once
				-the programming language is an abstract layer
					-allowing commands to be introduced in a structured way avoiding the interface
			-current CAD applications cannot consume the information generated by GD methods at same rhythm
				-the commands are generated faster than they are processed in the CAD application
				-huge delay until users can see 

		-readability
			-Readability is a usability requirement that influences directly the process of program understanding
				-program understand -> create conceptual model
				-conceptual model -> make sense of code -> read the vocabulary
			-Example: consider the program in processing that create a circle
				-before user make any sense of code he needs to answer some questions
				-it is the first barrier for a new user to understand the program
			-there is at least two strategies used to facilitate this process
				-improving the programming environment to supply more information while users read the code
				-designing a programming language closer to the human language (English-like syntax)
			-improving the programming environment
				-As Victor suggests the environment should be responsible for making program meaning transparent.
					-user should be able to look at line of code and understand what that means
					-for example: the program at figure x should be described as .. while user analyses each line of code
				-however this technique is rarely supported by the programming environments in general
					-users are supposed to know the language priori
					-users are supposed to know the language documentation
				-other techniques are used instead
					-professional environments allow users to navigate thought methods definition
						-direct access to the source code
					-bound/bind values (DrRacket)
						-open file definition
				-particularly in GD there is not such mechanism at all
				-Khan Academy's tutorials encourage the learner to address these questions by randomly adjusting numbers and trying to figure out what they do.
					-guessing the third argument of the "ellipse" function isn't "learning programming". It's simply a barrier to learning. In a modern environment, memorizing the minutia of an API should be as relevant as memorizing times tables.
			-designing a programming language
				-syntax is important
				-names matters
				-the lack
		
		-decomposition
			-Decomposition is a language capability that allows programs to be written in modules
				-modules are decomposed into several procedures
				-procedures into sub-procedures
			-Decomposition are related with the language paradigm
			-Breaking down a complex thing into understandable chunks is essential for understanding, perhaps the essence of understanding
			-Logo
			-Smalltalk
			-decomposition in GD
				-languages used in GD do not support decomposition as logo or smalltalk
				-for example: processing

		-recomposition
			-creating is remixing. To a large extent, new ideas are old ideas in new combinations.

			-a programming language must encourage recomposition -- grabbing parts of other programs, assembling them together, modifying them, building on top of them. This gives creators the initial material they need to create by reacting, instead of facing every new idea with a blank page. It also allows creators to learn from each other, instead of deriving techniques and style in a vacuum.

		-traceability
			-is the ability to verify the history, location, or application of an item by means of documented recorded identification.
			-cast the concept to GD
			-what we want
			-what we have

		-immediate feedback
			-acting by reacting
			-

		-documentation
			-the source of documentation of GD program are sketches made during software analysis


===============

How can I contribute to improve the programming methods in GD?

-Problem: How to get people to understanding programming?
	-program comprehension area proposed several theories
	-e.g. to understand a program user must create a mental model of it
	-before he can edit any line of code
	-this process is performed by reading the code line by line
	-fundamental key in this process is the documentation 
-Solution: Since early days of computing different methods were used to document programs.
	-text comments
	-formal documentation i.e. Java doc.
-Problem: Documentation as usual in software engineering are inadequate in other areas
	-develop this idea
-Problem: Documentation is rarely performed
	-but in GD it is in form of sketches
	-no reuse of this sketches
	-exemplify with real GD program...
-Solution: What I propose is a way to include other sources of documentation in code
	-e.g. images
	-Images are self explanatory, and will resolve several problem of program understand
	-To support images or other fonts of documentation in code the IDE should support rich comments..
-Problem: Few IDEs support this feature
	-images are just comments no part of code
	-special grammar to include this kind of statement
-Solution: To support this feature the IDE should provide a way to include rich media in the editor
-Problem: Usual UTF8 code becomes unreadable
-Solution: Indicates a path or a mode to load the image or not
-Problem: users delay documentation because it distracts him from the main task
-Solution: reuse the diagrams from analysis code
	-precondition is the diagram was made before coding
-Problem: images/comments becomes unrelated with code
	-the mains purpose of comment is to refer what each program component mean for the whole program
	-in GD this is even more explicit because the program express a geometric model itself
	-but there is no connection between the code and the geometric object
-Solution bind each program parameter to their documentation
	-what I propose is to relate each function parameter to their concept itself
	-function meaning becomes transparent
Problem: The usability becomes a problem without adequate mechanisms to deal with it
	-intense edit
	-images becomes outdated
	-references become broken
-Solution: Import images easily by copy and paste
	-edit directly
-Problem: How to automatic recognize symbols in images
-Solution: OCR
-Problem: It does not work as expected
-Solution: Fall back mechanism
-Problem: What the user want to see from the image?
-Solution: selective select
-Problem: Space spend with images in code
-Solution: hide/show comments

Problem: visual feed back is important because is a key factor for understanding what a program does
	-current programming environments support it in several way
	-none effective..
Solution: